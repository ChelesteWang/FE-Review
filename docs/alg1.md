### 关于缩减代码 

1.善用js中的函数或者特性。

（迭代、解构、set等等）

```java
// 使用箭头函数缩减代码
// 处理输入，可以用.map，需要注意其所有参数
// 此外其他迭代方法也需要掌握。
let line = readline().split(' ');
line = line.map((e) => parseInt(e));

// 去重
arr = [...new Set(arr)];
// 升序,排序可以用sort，默认是字典序,并且可以根据需要定制，需要深入掌握
arr.sort((a, b) => a - b);
// 迭代输出
arr.forEach((i) => console.log(i));
// 求最大值，使用扩展运算符...
max = Math.max.call(...arr);
// 复制数组
arr2 = [...arr1];
arr2 = arr.concat();
arr2 = arr.slice();

// 善用解构
// 变量赋值
let [a, b, c, d, e] = [1, 2, 3, 4, 5]; // a=1,b=2,c=3,d=4,e=5
// 交换变量值
[a, b] = [b, a];

// 题外话：字符串中的字符是无法交换的
let str = 'ab';
[str[0], str[1]] = [str[1], str[0]]; // 无效，"ab"
// 不过可以将字符串拆成字符数组后就可以交换了
str = str.split(''); // ["a","b"]
[str[0], str[1]] = [str[1], str[0]]; // ["b","a"]
```

2.善用位运算。

（相信我，能用位运算的就用位运算）

```java
// 求数组一半长度
halfLen = a.length >> 1;

// 不过需要注意右移运算符>>优先级别加号+还低，例如
console.log(3 + (5 - 3 >> 1)); // 2
console.log(3 + ~~((5 - 3) / 2)); // 4

// 因此在于其他操作符号想结合时候可以适当增加括号,例如求中位
mid = left + (right - left >> 1);
mid = left + ~~((right - left) / 2);
// 不建议使用mid = (left + right)>>1;，因为加号操作可能造成溢出

// ~~等价于Math.floor(),|0也等价于Math.floor()
halfLen = ~~(a.length / 2);
halfLen = a.length / 2 | 0;

// 判断奇偶
evenNum & 1 === 0; // 偶数
oddNum & 1 === 1; // 奇数

// 善用异或
5 ^ 5; // 0
5 ^ 5 ^ 6 ^ 6 ^ 7; // 7

// 判断数是否是2的幂次方
num & num - 1 === 0;

// 翻转数的第K位
num ^= 1 << k;

// 将第K位设为0
num &= ~(1 << k);

// 将第K位设为1
num |= 1 << K;

// 判断第K位是否为0
num & 1 << k === 0;
```

3.善用正则表达式。

（只要关于字符串的题目都应该联想到用正则表达式）

要会写正则，可以用正则表达式的几个函数也要掌握

正则中：exec，test

字符串中：search，match，replace，split

具体例子可以看我的：[百词斩春招笔试题解][Link 1]

4.少写函数。

刷题不是写业务代码，没有说要封装重用，AC才是王道。

并且写函数还要思考需要哪些参数，参数如何传递，会影响思考速度。

我们尽量做到的是，思考清楚后直接敲，越快越好，而不是一遍敲一边思考。

5.递归函数。

前面情况有例外，比如要写递归，就要写函数。递归函数可以减少代码。

不过还是建议用递归思想去想，用循环搭配数据结构（栈/队列）去解答

### 关于刷题方法 

1.审题先判断陷阱。

看到题目第一先看是否有时间复杂度、空间复杂度的要求。（比如大数问题、递归多了栈溢出等问题）

根据自己猜测判断使用简单方法，还是复杂方法来做，毕竟我们没有时间去做两遍题目。

然后再顺便看下是否需要判断边界条件（一般都需要出错判断）

有时间复杂度要求的，可以优化排序、动态规划、以空间换时间等

有空间复杂度要求的，可以用循环代替递归、动态规划代替递归等

这里讲下为什么不说贪心，第一理论上所有贪心可以解决的问题都可以用动态规划来做，第二正因如此，许多公司难题也就只考到了动态规划。

所以请一定一定要掌握动态规划。

2.联想。

我们遇到题目时要把题目和以前做过的题联想下，通过类似点，找出突破点。

1.  字符串问题====》正则
2.  链表、数组问题====》双指针
3.  数组问题====》利用数组下标来做====》有时需要额外数组==》此外大部分要考虑二分法优化时间复杂度
4.  多维数组问题====》降维来做。
5.  复杂问题、优化问题====》动态规划
6.  排列问题====》递归、回溯
7.  数论问题====》找规律、动态规划
8.  树的问题====》递归、深度遍历、广度遍历====》栈、队列
9.  次数问题====》哈希表存储（js中建议使用\{\}，而不要使用ES6中的Map）
10. 大小值问题====》栈、队列、哈希表做存储
11. 从前往后、从大到小比较复杂====》从后往前、从小到大思考。
12. 动态规划重点了解
13. 位运算也了解一下

3.必须掌握算法

快排和归并排序、深度和广度遍历、二分查找（能手撕）

动态规划、回溯法。

要专门根据题目分类去刷这些算法。

4.多画图。

对于涉及数据结构的题目，如链表、二叉树等一定要画图。

对于涉及概率的问题，可以画圈圈来交、并、补。

对于点线的问题，可以画坐标系。

5.多举例

对于复杂问题可以举不复杂的小例子来分析步骤。

对于数论问题可以举例子来找规律。

退一万步来说，假设你实在不会做，你也可以通过举例，自己if-else生产很多测试用例去满足题意。

这也是为什么我们刷题时，题目不会像剑指offer题目一样，告诉你的答案和题目的测试用例有哪些不同的原因。

6.剩下的能淘汰你的只有智力题了。

有些忘记了，暂时想到的先写这么多了，慢慢补充，有好的建议都可以发给我


[Link 1]: https://www.nowcoder.com/discuss/70412
